### 解法一  ###

一开始的暴力搜索，让数组内元素一一对比，以获取到最后和为所求数的2个元素。这时间复杂度就为n的平方级别。



### 解法二

使用了hash表。对于每一个元素，若能直接知道是否存在（target - 它自身 ）这一个数，然后对每一个数都一一找过去，这样最后时间复杂度就是n级别了。

想要实现一下子找对应数字O(1)，而又不涉及删除操作，故可以使用hash表。而在C++中，具体数据结构，可以使用封装好的unordered_map< , >，

具体而言：

**unordered_map**: unordered_map内部实现了一个**哈希表**（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，查找的时间复杂度可达到O(1)，其在海量数据处理中有着广泛应用）。因此，其元素的排列顺序是无序的。 

相关操作：

1. 创建：unordered_map<int, int> hash;
2. 赋值：因为重载了[]，故可以直接如下赋值：hash[890] = i;
3. 取值：hast[890]; 这样便可以取得890所对应的那个值；
4. 查找：hash.find(numberToFind) != hash.end() ； 注意，这里查找的都是上面赋值中 890 等一系列数，
5. 遍历：可以使用迭代器来遍历。



i++比 ++i，在leetcode中快了几ms。